use proc_macro::TokenStream;
use syn::{parse_macro_input};

mod param_utils;
mod use_tree_processor;
mod use_statement_processor;
mod inline_processor;
mod function_mock;
mod function_fake;
mod function_stub;
mod return_utils;

use crate::function_mock::{process_mock_function};
use crate::function_fake::{process_fake_function};
use crate::function_mock::mock_args::MockFunctionArgs;
use crate::function_stub::{process_stub_function};
use crate::inline_processor::process_inline;
use crate::use_statement_processor::process_use_statement;

/// Attribute macro that generates a mockable version of a function.
///
/// This macro modifies the original function to check (in test mode) if a mock implementation
/// has been configured and generates:
/// 1. The original function with injected mock checking logic (calls mock if set, otherwise executes normally)
/// 2. A `<function_name>_mock` module containing mock control methods
///
/// # Generated Mock Module Methods
///
/// - `setup(fn)` - Sets a custom implementation for the mock
/// - `clear()` - Resets the mock to its uninitialized state
/// - `is_set()` - Checks if the mock has been configured
/// - `assert_times(n)` - Verifies the function was called exactly n times
/// - `assert_with(params)` - Verifies the function was called with specific parameters
///
/// # Ignoring of parameters
///
/// If you don't want a parameter to be checked (for example if they have to be a reference or do not implement Clone / PartialEq),
/// you can ignore the parameter with:
///
/// ```ignore
/// #[mock_function(ignore = [db])]
/// pub(crate) fn fetch_user(db: SqlitePool /* Doesn't implement PartialEq */, id: u32) -> Result<String, String> {
///     // Real implementation
///     Ok(format!("user_{}", id))
/// }
/// ```
///
/// # Requirements
///
/// - Function must not have `self` parameters (standalone functions only)
/// - Not ignored function parameters must implement `Clone`, `Debug`, and `PartialEq` (for assertions)
/// - Not ignored function parameters must be `'static` (no references allowed - use owned types like `String` instead of `&str`)
///
/// # Example
///
/// ```ignore
/// use fnmock::derive::mock_function;
///
/// #[mock_function]
/// pub(crate) fn fetch_user(id: u32) -> Result<String, String> {
///     // Real implementation
///     Ok(format!("user_{}", id))
/// }
///
/// #[cfg(test)]
/// mod tests {
///     use super::*;
///
///     #[test]
///     fn test_with_mock() {
///         // Set up mock behavior
///         fetch_user_mock::setup(|id| {
///             Ok(format!("mock_user_{}", id))
///         });
///
///         // Call the original function (which will use the mock in tests)
///         let result = fetch_user(42);
///
///         // Verify behavior
///         assert_eq!(result, Ok("mock_user_42".to_string()));
///         fetch_user_mock::assert_times(1);
///         fetch_user_mock::assert_with(42);
///
///         // Clean up (not necessary since mocks are thread-local and reset between tests)
///         fetch_user_mock::clear();
///     }
/// }
/// ```
/// # Note
///
/// The mock module uses thread-local storage, so mocks are isolated
/// between tests but **not thread-safe** if the same function is mocked in parallel
/// test threads.
///
/// This means if you write a test that spawns multiple threads
/// and those threads all try to mock the same function simultaneously,
/// you could encounter undefined behavior.
/// The mock state is isolated between different test threads (good for test independence),
/// but not protected within a single test that uses multiple threads.
#[proc_macro_attribute]
pub fn mock_function(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemFn);
    let args = if attr.is_empty() {
        MockFunctionArgs { ignore: Vec::new() }
    } else {
        parse_macro_input!(attr as MockFunctionArgs)
    };

    match process_mock_function(input, args.ignore) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that conditionally imports functions and their mock versions.
///
/// This macro transforms a use statement to import the original function in production
/// code and the mock version (with `_mock` suffix) aliased to the original name in test code.
///
/// # Requirements
///
/// - The imported functions must have corresponding `_mock` versions generated by
///   the `#[mock_function]` attribute macro
/// - Only works with simple path imports and grouped imports
/// - Does not support glob imports (`*`) or renamed imports (`as`)
/// - Since the as syntax is used, there can't be a declaration with the same name as the function.
///   For example if the function is named `add_two` the module `add_two` can't be declared in the same module.
///
/// # Supported Patterns
///
/// ## Single function import:
/// ```ignore
/// #[use_mock]
/// use module::function;
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use module::function;
/// #[cfg(test)]
/// use module::function_mock as function;
/// ```
///
/// ## Multiple function imports:
/// ```ignore
/// #[use_mock]
/// use crate::service::{fetch_user, send_email};
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use crate::service::{fetch_user, send_email};
/// #[cfg(test)]
/// use crate::service::{fetch_user_mock as fetch_user, send_email_mock as send_email};
/// ```
#[proc_macro_attribute]
pub fn use_mock(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemUse);

    match process_use_statement(input, "_mock") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Function-like procedural macro that conditionally selects between a function and its mock version inline.
///
/// This macro takes a function identifier and returns a block expression that evaluates to either
/// the original function in production builds or the mock version (with `_mock` suffix) in test builds.
/// The returned function can be immediately invoked with arguments using the syntax:
/// `use_mock_inline!(function_name)(args...)`
///
/// # Use Cases
///
/// In general, it is preferable to use the `#[use_mock]` attribute macro,
/// since it doesn't need to be placed in the code itself and mocks
/// all calls to the function in the module.
///
/// This macro should be used when:
/// - **You want to mock a function in the same module**
/// - You want to mock function calls inline without modifying import statements
/// - You need fine-grained control over which specific call sites use mocks vs. real implementations
///
/// # Requirements
///
/// - The function must have a corresponding `_mock` version generated by the `#[mock_function]` attribute macro
/// - The function identifier must be a simple path (e.g., `function_name` or `module::function_name`)
/// - If you want to use use_mock_inline together with a use statement, include the module before the function, not the function itself.
///   So `use first_module::second_module::function` and `use_mock_inline!(function)` is not allowed, but `use_mock_inline!(second_module::function)` is.
///
/// # Syntax
///
/// ## Function in the same module
///
/// ```ignore
/// use_mock_inline!(function_name)(arg1, arg2, ...)
/// ```
///
/// ## Function from different module
///
/// ```ignore
/// use_mock_inline!(path::function_name)(arg1, arg2, ...)
/// ```
///
/// # Expansion
///
/// The macro call:
/// ```ignore
/// use_mock_inline!(divide)(sum(data.clone()), data.len() as f32)
/// ```
/// Expands to:
/// ```ignore
/// {
///     #[cfg(not(test))]
///     { divide }
///     #[cfg(test)]
///     { divide_mock }
/// }(sum(data.clone()), data.len() as f32)
/// ```
///
/// # Note
///
/// You can nest this macro.
///
/// ```ìgnore
/// use_mock_inline!(divide)(
///     use_mock_inline!(sum)(data.clone()),
///     data.len() as f32
/// )
/// ```
#[proc_macro]
pub fn use_mock_inline(item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::Expr);

    match process_inline(input, "_mock", "use_mock_inline") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that generates a fakeable version of a function.
///
/// This macro modifies the original function to check (in test mode) if a fake implementation
/// has been configured and generates:
/// 1. The original function with injected fake checking logic (calls fake if set, otherwise executes normally)
/// 2. A `<function_name>_fake` module containing fake control methods
///
/// # Generated Fake Module Methods
///
/// - `setup(fn)` - Sets a custom implementation for the fake
/// - `clear()` - Resets the fake to its uninitialized state
/// - `is_set()` - Checks if the fake has been configured
/// - `get_implementation()` - Gets the current fake implementation
///
/// # Difference from Mocks
///
/// Fakes - in contrast to mocks - do not let you make assertions about if and how
/// the function was called. Fakes are simpler and only provide alternative implementations.
///
/// One important advantage of fakes is, that they **allow references as parameters**, unlike mocks.
/// This is the case, because they don't need to store the provided parameters and therefore don't cause lifetime issues.
///
/// # Requirements
///
/// - Function must not have `self` parameters (standalone functions only)
///
/// # Example
///
/// ```ignore
/// use fnmock::derive::fake_function;
///
/// #[fake_function]
/// pub(crate) fn add_two(x: i32) -> i32 {
///     x + 2
/// }
///
/// #[cfg(test)]
/// mod tests {
///     use super::*;
///
///     #[test]
///     fn test_with_fake() {
///         // Set up fake behavior
///         add_two_fake::setup(|x| x + 10);
///
///         // Call the original function (which will use the fake in tests)
///         let result = add_two(5);
///
///         // Verify behavior
///         assert_eq!(result, 15);
///
///         // Clean up (not necessary since fakes are thread-local and reset between tests)
///         add_two_fake::clear();
///     }
/// }
/// ```
/// # Note
///
/// The fake module uses thread-local storage, so fakes are isolated
/// between tests but **not thread-safe** if the same function is faked in parallel
/// test threads.
#[proc_macro_attribute]
pub fn fake_function(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemFn);

    match process_fake_function(input) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that conditionally imports functions and their fake versions.
///
/// This macro transforms a use statement to import the original function in production
/// code and the fake version (with `_fake` suffix) aliased to the original name in test code.
///
/// # Requirements
///
/// - The imported functions must have corresponding `_fake` versions generated by
///   the `#[fake_function]` attribute macro
/// - Only works with simple path imports and grouped imports
/// - Does not support glob imports (`*`) or renamed imports (`as`)
/// - Since the `as` syntax is used, there can't be a declaration with the same name as the function.
///   For example if the function is named `add_two` the module `add_two` can't be declared in the same module.
///
/// # Supported Patterns
///
/// ## Single function import:
/// ```ignore
/// #[use_fake]
/// use module::function;
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use module::function;
/// #[cfg(test)]
/// use module::function_fake as function;
/// ```
///
/// ## Multiple function imports:
/// ```ignore
/// #[use_fake]
/// use crate::service::{fetch_user, send_email};
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use crate::service::{fetch_user, send_email};
/// #[cfg(test)]
/// use crate::service::{fetch_user_fake as fetch_user, send_email_fake as send_email};
/// ```
#[proc_macro_attribute]
pub fn use_fake(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemUse);

    match process_use_statement(input, "_fake") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Function-like procedural macro that conditionally selects between a function and its fake version inline.
///
/// This macro takes a function identifier and returns a block expression that evaluates to either
/// the original function in production builds or the fake version (with `_fake` suffix) in test builds.
/// The returned function can be immediately invoked with arguments using the syntax:
/// `use_fake_inline!(function_name)(args...)`
///
/// # Use Cases
///
/// In general, it is preferable to use the `#[use_fake]` attribute macro,
/// since it doesn't need to be placed in the code itself and fakes
/// all calls to the function in the module.
///
/// This macro should be used when:
/// - **You want to fake a function in the same module**
/// - You want to fake function calls inline without modifying import statements
/// - You need fine-grained control over which specific call sites use fakes vs. real implementations
///
/// # Requirements
///
/// - The function must have a corresponding `_fake` version generated by the `#[fake_function]` attribute macro
/// - The function identifier must be a simple path (e.g., `function_name` or `module::function_name`)
/// - If you want to use use_fake_inline together with a use statement, include the module before the function, not the function itself.
///   So `use first_module::second_module::function` and `use_fake_inline!(function)` is not allowed, but `use_fake_inline!(second_module::function)` is.
///
/// # Syntax
///
/// ## Function in the same module
///
/// ```ignore
/// use_fake_inline!(function_name)(arg1, arg2, ...)
/// ```
///
/// ## Function from different module
///
/// ```ignore
/// use_fake_inline!(path::function_name)(arg1, arg2, ...)
/// ```
///
/// # Expansion
///
/// The macro call:
/// ```ignore
/// use_fake_inline!(add_two)(5)
/// ```
/// Expands to:
/// ```ignore
/// {
///     #[cfg(not(test))]
///     { add_two }
///     #[cfg(test)]
///     { add_two_fake }
/// }(5)
/// ```
///
/// # Note
///
/// You can nest this macro.
///
/// ```ìgnore
/// use_fake_inline!(divide)(
///     use_fake_inline!(sum)(data.clone()),
///     data.len() as f32
/// )
/// ```
#[proc_macro]
pub fn use_fake_inline(item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::Expr);

    match process_inline(input, "_fake", "use_fake_inline") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that generates a stubbable version of a function.
///
/// This macro modifies the original function to check (in test mode) if a stub implementation
/// has been configured and generates:
/// 1. The original function with injected stub checking logic (calls stub if set, otherwise executes normally)
/// 2. A `<function_name>_stub` module containing stub control methods
///
/// # Generated Stub Module Methods
///
/// - `setup(return_value)` - Sets the predetermined return value for the stub
/// - `clear()` - Resets the stub to its uninitialized state
/// - `is_set()` - Checks if the stub has been configured
/// - `get_return_value()` - Gets the current stubbed return value
///
/// # Difference from Mocks and Fakes
///
/// Stubs - in contrast to mocks and fakes - provide canned responses without behavior verification or custom logic.
/// They simply return predetermined values to allow tests to proceed.
///
/// - **Mocks** track calls and allow assertions, and use custom implementations
/// - **Fakes** provide custom implementations without tracking
/// - **Stubs** only return predetermined values without custom logic or tracking
///
/// # Requirements
///
/// - Function must not have `self` parameters (standalone functions only)
/// - Return type must implement `Clone` (since the stub may be called multiple times)
///
/// # Example
///
/// ```ignore
/// use fnmock::derive::stub_function;
///
/// #[stub_function]
/// pub(crate) fn get_config() -> String {
///     // Real implementation that reads from file
///     std::fs::read_to_string("config.json").unwrap()
/// }
///
/// #[cfg(test)]
/// mod tests {
///     use super::*;
///
///     #[test]
///     fn test_with_stub() {
///         // Set up stub return value
///         get_config_stub::setup("test_config".to_string());
///
///         // Call the original function (which will use the stub in tests)
///         let result = get_config();
///
///         // Verify result
///         assert_eq!(result, "test_config");
///
///         // Clean up (not necessary since stubs are thread-local and reset between tests)
///         get_config_stub::clear();
///     }
/// }
/// ```
/// # Note
///
/// The stub module uses thread-local storage, so stubs are isolated
/// between tests but **not thread-safe** if the same function is stubbed in parallel
/// test threads.
#[proc_macro_attribute]
pub fn stub_function(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemFn);

    match process_stub_function(input) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that conditionally imports functions and their stub versions.
///
/// This macro transforms a use statement to import the original function in production
/// code and the stub version (with `_stub` suffix) aliased to the original name in test code.
///
/// # Requirements
///
/// - The imported functions must have corresponding `_stub` versions generated by
///   the `#[stub_function]` attribute macro
/// - Only works with simple path imports and grouped imports
/// - Does not support glob imports (`*`) or renamed imports (`as`)
/// - Since the `as` syntax is used, there can't be a declaration with the same name as the function.
///   For example if the function is named `get_config` the module `get_config` can't be declared in the same module.
///
/// # Supported Patterns
///
/// ## Single function import:
/// ```ignore
/// #[use_stub]
/// use module::function;
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use module::function;
/// #[cfg(test)]
/// use module::function_stub as function;
/// ```
///
/// ## Multiple function imports:
/// ```ignore
/// #[use_stub]
/// use crate::config::{get_config, get_secret};
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use crate::config::{get_config, get_secret};
/// #[cfg(test)]
/// use crate::config::{get_config_stub as get_config, get_secret_stub as get_secret};
/// ```
#[proc_macro_attribute]
pub fn use_stub(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemUse);

    match process_use_statement(input, "_stub") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Function-like procedural macro that conditionally selects between a function and its stub version inline.
///
/// This macro takes a function identifier and returns a block expression that evaluates to either
/// the original function in production builds or the stub version (with `_stub` suffix) in test builds.
/// The returned function can be immediately invoked with arguments using the syntax:
/// `use_stub_inline!(function_name)(args...)`
///
/// # Use Cases
///
/// In general, it is preferable to use the `#[use_stub]` attribute macro,
/// since it doesn't need to be placed in the code itself and stubs
/// all calls to the function in the module.
///
/// This macro should be used when:
/// - **You want to stub a function in the same module**
/// - You want to stub function calls inline without modifying import statements
/// - You need fine-grained control over which specific call sites use stubs vs. real implementations
///
/// # Requirements
///
/// - The function must have a corresponding `_stub` version generated by the `#[stub_function]` attribute macro
/// - The function identifier must be a simple path (e.g., `function_name` or `module::function_name`)
/// - If you want to use use_stub_inline together with a use statement, include the module before the function, not the function itself.
///   So `use first_module::second_module::function` and `use_stub_inline!(function)` is not allowed, but `use_stub_inline!(second_module::function)` is.
///
/// # Syntax
///
/// ## Function in the same module
///
/// ```ignore
/// use_stub_inline!(function_name)(arg1, arg2, ...)
/// ```
///
/// ## Function from different module
///
/// ```ignore
/// use_stub_inline!(path::function_name)(arg1, arg2, ...)
/// ```
///
/// # Expansion
///
/// The macro call:
/// ```ignore
/// use_stub_inline!(get_config)()
/// ```
/// Expands to:
/// ```ignore
/// {
///     #[cfg(not(test))]
///     { get_config }
///     #[cfg(test)]
///     { get_config_stub }
/// }()
/// ```
///
/// # Note
///
/// You can nest this macro.
///
/// ```ìgnore
/// use_stub_inline!(process_data)(
///     use_stub_inline!(get_config)()
/// )
/// ```
#[proc_macro]
pub fn use_stub_inline(item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::Expr);

    match process_inline(input, "_stub", "use_stub_inline") {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}