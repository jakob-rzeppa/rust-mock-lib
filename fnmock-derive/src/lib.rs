use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input};

mod param_utils;
mod use_tree_processor;
mod function_mock;
mod return_utils;

use crate::function_mock::{process_mock_function};
use crate::function_mock::use_function_mock::{process_use_function_mock};
use crate::function_mock::use_inline_mock::process_inline_mock;

/// Attribute macro that generates a mockable version of a function.
///
/// This macro preserves the original function and generates:
/// 1. A `<function_name>_mock` function that can be called in tests
/// 2. A `<function_name>_mock` module containing mock control methods
///
/// # Generated Mock Module Methods
///
/// - `mock_implementation(fn)` - Sets a custom implementation for the mock
/// - `clear_mock()` - Resets the mock to its default panic behavior
/// - `assert_times(n)` - Verifies the function was called exactly n times
/// - `assert_with(params)` - Verifies the function was called with specific parameters
///
/// # Requirements
///
/// - Function must not have `self` parameters (standalone functions only)
/// - Function parameters must implement `Clone`, `Debug`, and `PartialEq` (for assertions)
/// - Function parameters must be `'static` (no references allowed - use owned types like `String` instead of `&str`)
///
/// # Example
///
/// ```ignore
/// use fnmock::derive::mock_function;
///
/// #[mock_function]
/// pub(crate) fn fetch_user(id: u32) -> Result<String, String> {
///     // Real implementation
///     Ok(format!("user_{}", id))
/// }
///
/// #[cfg(test)]
/// mod tests {
///     use super::*;
///
///     #[test]
///     fn test_with_mock() {
///         // Set up mock behavior
///         fetch_user_mock::mock_implementation(|id| {
///             Ok(format!("mock_user_{}", id))
///         });
///
///         // Call the mock
///         let result = fetch_user_mock(42);
///
///         // Verify behavior
///         assert_eq!(result, Ok("mock_user_42".to_string()));
///         fetch_user_mock::assert_times(1);
///         fetch_user_mock::assert_with(42);
///
///         // Clean up
///         fetch_user_mock::clear_mock();
///     }
/// }
/// ```
///
/// # Note
///
/// The mock function and module use thread-local storage, so mocks are isolated
/// between tests but **not thread-safe** if the same function is mocked in parallel
/// test threads.
///
/// This means if you write a test that spawns multiple threads
/// and those threads all try to mock the same function simultaneously,
/// you could encounter undefined behavior.
/// The mock state is isolated between different test threads (good for test independence),
/// but not protected within a single test that uses multiple threads.
#[proc_macro_attribute]
pub fn mock_function(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemFn);

    match process_mock_function(input) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Attribute macro that conditionally imports functions and their mock versions.
///
/// This macro transforms a use statement to import the original function in production
/// code and the mock version (with `_mock` suffix) aliased to the original name in test code.
///
/// # Requirements
///
/// - The imported functions must have corresponding `_mock` versions generated by
///   the `#[mock_function]` attribute macro
/// - Only works with simple path imports and grouped imports
/// - Does not support glob imports (`*`) or renamed imports (`as`)
/// - Since the as syntax is used, there can't be a declaration with the same name as the function.
///   For example if the function is named `add_two` the module `add_two` can't be declared in the same module.
///
/// # Supported Patterns
///
/// ## Single function import:
/// ```ignore
/// #[use_function_mock]
/// use module::function;
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use module::function;
/// #[cfg(test)]
/// use module::function_mock as function;
/// ```
///
/// ## Multiple function imports:
/// ```ignore
/// #[use_function_mock]
/// use crate::service::{fetch_user, send_email};
/// ```
/// Expands to:
/// ```ignore
/// #[cfg(not(test))]
/// use crate::service::{fetch_user, send_email};
/// #[cfg(test)]
/// use crate::service::{fetch_user_mock as fetch_user, send_email_mock as send_email};
/// ```
#[proc_macro_attribute]
pub fn use_function_mock(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemUse);

    match process_use_function_mock(input) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}

/// Function-like procedural macro that conditionally selects between a function and its mock version inline.
///
/// This macro takes a function identifier and returns a block expression that evaluates to either
/// the original function in production builds or the mock version (with `_mock` suffix) in test builds.
/// The returned function can be immediately invoked with arguments using the syntax:
/// `use_inline_mock!(function_name)(args...)`
///
/// # Use Cases
///
/// In general, it is preferable to use the `#[use_function_mock]` attribute macro,
/// since it doesn't need to be placed in the code itself and mocks
/// all calls to the function in the module.
///
/// This macro should be used when:
/// - **You want to mock a function in the same module**
/// - You want to mock function calls inline without modifying import statements
/// - You need fine-grained control over which specific call sites use mocks vs. real implementations
///
/// # Requirements
///
/// - The function must have a corresponding `_mock` version generated by the `#[mock_function]` attribute macro
/// - The function identifier must be a simple path (e.g., `function_name` or `module::function_name`)
/// - If you want to use use_inline_mock together with a use statement, include the module before the function, not the function itself.
///   So `use first_module::second_module::function` and `use_inline_mock!(function)` is not allowed, but `use_inline_mock!(second_module::function)` is.
///
/// # Syntax
///
/// ```ignore
/// use_inline_mock!(function_name)(arg1, arg2, ...)
/// ```
///
/// # Expansion
///
/// The macro call:
/// ```ignore
/// use_inline_mock!(divide)(sum(data.clone()), data.len() as f32)
/// ```
/// Expands to:
/// ```ignore
/// {
///     #[cfg(not(test))]
///     { divide }
///     #[cfg(test)]
///     { divide_mock }
/// }(sum(data.clone()), data.len() as f32)
/// ```
///
/// # Note
///
/// You can nest this macro.
///
/// ```Ã¬gnore
/// use_inline_mock!(divide)(
///     use_inline_mock!(sum)(data.clone()),
///     data.len() as f32
/// )
/// ```
#[proc_macro]
pub fn use_inline_mock(item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::Expr);

    match process_inline_mock(&input) {
        Ok(expanded) => TokenStream::from(expanded),
        Err(e) => e.to_compile_error().into(),
    }
}